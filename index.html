<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>FLUX MONO</title>
    <style>
        :root {
            --bg: #000000;
            --fg: #ffffff;
            --dim: #444444;
            --accent: #ffffff;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: "Courier New", Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            height: 100vh; /* Fallback */
            height: 100dvh; /* Mobile viewport fix */
            margin: 0;
            overflow: hidden;
            touch-action: none; /* Отключаем жесты браузера */
            -webkit-user-select: none;
            user-select: none;
        }

        /* --- UI Header --- */
        header {
            width: 100%;
            padding: 20px;
            text-align: center;
            border-bottom: 1px solid var(--dim);
            letter-spacing: 4px;
            text-transform: uppercase;
            font-size: 1.2rem;
            box-sizing: border-box;
        }

        /* --- Visualizer --- */
        #canvas-container {
            flex-grow: 1;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .status-text {
            position: absolute;
            font-size: 10px;
            color: var(--dim);
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* --- Controls Area --- */
        .controls {
            width: 100%;
            padding: 20px 20px 40px 20px;
            background: var(--bg);
            border-top: 1px solid var(--dim);
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        /* --- Sliders --- */
        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            text-transform: uppercase;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]:focus { outline: none; }

        /* Track */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: var(--dim);
            border-radius: 0px;
        }
        
        /* Thumb (Handle) */
        input[type=range]::-webkit-slider-thumb {
            height: 20px;
            width: 20px;
            border-radius: 0; /* Квадратные ручки */
            background: var(--bg);
            border: 2px solid var(--fg);
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -10px; /* Center on track */
        }

        /* --- Main Button --- */
        #toggleBtn {
            background: transparent;
            color: var(--fg);
            border: 2px solid var(--fg);
            padding: 20px;
            font-family: inherit;
            font-size: 16px;
            text-transform: uppercase;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }

        #toggleBtn:active {
            transform: scale(0.98);
        }

        /* Active State style */
        body.active #toggleBtn {
            background: var(--fg);
            color: var(--bg);
        }

        /* Индикатор записи */
        .rec-dot {
            width: 10px;
            height: 10px;
            background: var(--fg);
            border-radius: 50%;
            display: none;
        }
        body.active .rec-dot { display: block; animation: blink 2s infinite; }

        @keyframes blink { 0% {opacity:1;} 50% {opacity:0.2;} 100% {opacity:1;} }

        /* Warning Overlay for Orientation/Headphones */
        #overlay {
            display: none; /* JS will show if needed */
        }

    </style>
</head>
<body>

    <header>Flux Mono</header>

    <div id="canvas-container">
        <canvas id="vizCanvas"></canvas>
        <div class="status-text" id="statusMsg">READY TO INITIALIZE</div>
    </div>

    <div class="controls">
        
        <div class="slider-group">
            <div class="slider-label"><span>Grain Size</span><span id="val-size">0.2s</span></div>
            <input type="range" id="grainSize" min="0.05" max="0.5" step="0.01" value="0.2">
        </div>

        <div class="slider-group">
            <div class="slider-label"><span>Density</span><span id="val-dens">High</span></div>
            <!-- Инвертируем визуально: влево (мало мс) = густо, вправо (много мс) = редко -->
            <input type="range" id="density" min="20" max="400" step="10" value="100" style="direction: rtl">
        </div>

        <div class="slider-group">
            <div class="slider-label"><span>Atmosphere</span><span id="val-mix">70%</span></div>
            <input type="range" id="verbMix" min="0" max="1" step="0.01" value="0.7">
        </div>

        <button id="toggleBtn">
            <div class="rec-dot"></div>
            <span id="btnText">INITIALIZE SYSTEM</span>
        </button>
    </div>

    <script>
        // --- UI Logic ---
        const btn = document.getElementById('toggleBtn');
        const btnText = document.getElementById('btnText');
        const statusMsg = document.getElementById('statusMsg');
        const body = document.body;
        
        // Sliders feedback
        document.getElementById('grainSize').oninput = (e) => document.getElementById('val-size').innerText = e.target.value + 's';
        document.getElementById('density').oninput = (e) => document.getElementById('val-dens').innerText = e.target.value < 100 ? "MAX" : (e.target.value > 300 ? "LOW" : "MID");
        document.getElementById('verbMix').oninput = (e) => document.getElementById('val-mix').innerText = Math.round(e.target.value * 100) + '%';

        // --- Audio Globals ---
        let audioCtx;
        let isRunning = false;
        let micStream;
        let sourceNode, recorderNode;
        let schedulerInterval;
        let analyser;
        
        // Buffers
        const BUFFER_SECS = 4; // Меньше для мобильных (экономия памяти)
        let audioBufferL;
        let writePointer = 0;
        let bufferLength = 0;

        // Nodes
        let dryGain, wetGain, compressor, reverbNode;

        // --- Canvas Visualizer ---
        const canvas = document.getElementById('vizCanvas');
        const ctx = canvas.getContext('2d');
        let drawVisual;

        function resizeCanvas() {
            canvas.width = canvas.parentElement.offsetWidth;
            canvas.height = canvas.parentElement.offsetHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- Core Audio Logic ---

        btn.addEventListener('click', async () => {
            if (!isRunning) {
                await startAudio();
            } else {
                stopAudio();
            }
        });

        async function startAudio() {
            try {
                btnText.innerText = "STARTING...";
                
                // 1. Context Init (iOS Hack: Create context inside user gesture)
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive'
                    });
                }
                
                // iOS: Resume if suspended
                if (audioCtx.state === 'suspended') {
                    await audioCtx.resume();
                }

                // 2. Microphone Access
                // На мобильных важно просить 'echoCancellation: false', иначе звук будет "задыхаться"
                micStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { 
                        echoCancellation: false, 
                        noiseSuppression: false,
                        autoGainControl: false 
                    } 
                });

                // 3. Setup Buffers
                bufferLength = audioCtx.sampleRate * BUFFER_SECS;
                audioBufferL = new Float32Array(bufferLength);
                writePointer = 0;

                // 4. Setup Graph
                sourceNode = audioCtx.createMediaStreamSource(micStream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 256; // Low resolution for performance style

                // Recorder (ScriptProcessor is simpler for single-file demo than AudioWorklet)
                recorderNode = audioCtx.createScriptProcessor(4096, 1, 1);
                recorderNode.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    for (let i = 0; i < input.length; i++) {
                        audioBufferL[writePointer] = input[i];
                        writePointer = (writePointer + 1) % bufferLength;
                    }
                };

                // FX Setup
                await setupEffects();

                // Connections
                sourceNode.connect(analyser); // Для визуализации
                sourceNode.connect(recorderNode);
                recorderNode.connect(audioCtx.destination); // Keep alive

                // Start Engine
                startGranularEngine();
                visualize();

                // UI Update
                isRunning = true;
                body.classList.add('active');
                btnText.innerText = "STOP CAPTURE";
                statusMsg.innerText = "LISTENING / PROCESSING";

            } catch (err) {
                console.error(err);
                btnText.innerText = "ERROR";
                statusMsg.innerText = "MIC ACCESS DENIED OR NOT SUPPORTED";
                alert("Ошибка: " + err.message + "\nПожалуйста, используйте Safari (iOS) или Chrome (Android) и разрешите доступ к микрофону.");
            }
        }

        function stopAudio() {
            if (schedulerInterval) clearInterval(schedulerInterval);
            if (sourceNode) sourceNode.disconnect();
            if (recorderNode) recorderNode.disconnect();
            if (micStream) micStream.getTracks().forEach(track => track.stop());
            if (audioCtx) audioCtx.suspend();
            
            cancelAnimationFrame(drawVisual);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            isRunning = false;
            body.classList.remove('active');
            btnText.innerText = "RESUME SYSTEM";
            statusMsg.innerText = "SYSTEM PAUSED";
        }

        // --- Granular Engine ---
        function startGranularEngine() {
            const getDensity = () => parseInt(document.getElementById('density').value);
            
            const run = () => {
                if (!isRunning) return;
                spawnGrain();
                // Randomize timing slightly for organic feel
                setTimeout(run, getDensity() + (Math.random() * 20));
            };
            run();
        }

        function spawnGrain() {
            if (audioCtx.state !== 'running') return;

            const grainSize = parseFloat(document.getElementById('grainSize').value);
            const grainLen = Math.floor(grainSize * audioCtx.sampleRate);
            
            // Random offset in past (0.1s to 2.5s)
            const offset = Math.floor((Math.random() * 2.4 + 0.1) * audioCtx.sampleRate);
            let readPos = writePointer - offset;
            if (readPos < 0) readPos += bufferLength;

            // Prepare buffer
            const grainBuff = audioCtx.createBuffer(1, grainLen, audioCtx.sampleRate);
            const data = grainBuff.getChannelData(0);

            // Copy with loop wrap-around
            for (let i = 0; i < grainLen; i++) {
                let idx = (readPos + i) % bufferLength;
                data[i] = audioBufferL[idx];
            }

            // Playback
            const src = audioCtx.createBufferSource();
            src.buffer = grainBuff;
            
            // Pitch randomization (Lower and slower = more ambient)
            // Range: 0.5 (octave down) to 1.1 (slight pitch up)
            src.playbackRate.value = 0.5 + (Math.random() * 0.6);

            // Envelope
            const env = audioCtx.createGain();
            const now = audioCtx.currentTime;
            env.gain.setValueAtTime(0, now);
            env.gain.linearRampToValueAtTime(0.6, now + (grainSize * 0.4)); // Attack
            env.gain.linearRampToValueAtTime(0, now + grainSize);       // Release

            // Panner
            const panner = audioCtx.createStereoPanner();
            panner.pan.value = (Math.random() * 2) - 1;

            // Connect
            src.connect(env);
            env.connect(panner);
            panner.connect(dryGain);
            panner.connect(wetGain);

            src.start();
        }

        async function setupEffects() {
            // Reverb
            reverbNode = audioCtx.createConvolver();
            reverbNode.buffer = createNoiseImpulse(2.5); // 2.5s tail

            // Compressor (Safety)
            compressor = audioCtx.createDynamicsCompressor();
            compressor.threshold.value = -12;
            compressor.ratio.value = 10;
            
            dryGain = audioCtx.createGain();
            wetGain = audioCtx.createGain();

            updateMix();
            document.getElementById('verbMix').addEventListener('input', updateMix);

            dryGain.connect(compressor);
            wetGain.connect(reverbNode);
            reverbNode.connect(compressor);
            compressor.connect(audioCtx.destination);
        }

        function updateMix() {
            const mix = parseFloat(document.getElementById('verbMix').value);
            dryGain.gain.value = 1.0 - (mix * 0.4); // Never fully mute dry
            wetGain.gain.value = mix;
        }

        function createNoiseImpulse(duration) {
            const len = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(2, len, audioCtx.sampleRate);
            for (let c = 0; c < 2; c++) {
                const data = buffer.getChannelData(c);
                for (let i = 0; i < len; i++) {
                    // Exponential decay
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 3);
                }
            }
            return buffer;
        }

        // --- Visualizer ---
        function visualize() {
            const bufferLengthAlt = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLengthAlt);

            const draw = () => {
                if (!isRunning) return;
                drawVisual = requestAnimationFrame(draw);

                analyser.getByteTimeDomainData(dataArray);

                ctx.fillStyle = 'rgb(0, 0, 0)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgb(255, 255, 255)';
                ctx.beginPath();

                const sliceWidth = canvas.width * 1.0 / bufferLengthAlt;
                let x = 0;

                for(let i = 0; i < bufferLengthAlt; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;

                    if(i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                ctx.lineTo(canvas.width, canvas.height/2);
                ctx.stroke();
            };
            draw();
        }

    </script>
</body>
</html>