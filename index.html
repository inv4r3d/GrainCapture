<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FLUX: MORPH</title>
    <style>
        body {
            background-color: #000;
            color: #eee;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        /* --- VISUALS --- */
        #viz-area {
            flex-grow: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-bottom: 1px solid #333;
        }

        /* Индикатор режима: Reality vs Dream */
        #mode-label {
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 5px;
            color: #555;
            transition: color 0.2s;
        }

        #grain-indicator {
            width: 10px; height: 10px;
            background: #fff;
            border-radius: 50%;
            margin-top: 20px;
            opacity: 0;
            box-shadow: 0 0 15px #fff;
        }

        .warning-text {
            position: absolute;
            top: 10px;
            color: #ffaa00;
            font-size: 10px;
            background: rgba(20,20,0,0.8);
            padding: 5px;
            border-radius: 4px;
            display: none; /* Show only when monitoring */
        }

        /* --- CONTROLS --- */
        .controls {
            padding: 20px;
            background: #111;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        /* Слайдер MORPH - Самый главный */
        .morph-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .morph-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #888;
            font-weight: bold;
        }

        input[type=range] { width: 100%; height: 30px; -webkit-appearance: none; background: transparent; }
        
        /* Стилизация ползунка */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 28px; width: 28px;
            background: #fff;
            border-radius: 50%;
            margin-top: -12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: #333; border-radius: 2px;
        }

        /* Обычные кнопки */
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        button {
            border: none; padding: 15px;
            font-size: 14px; font-weight: bold;
            text-transform: uppercase; cursor: pointer;
            font-family: monospace;
        }
        #btn-start { background: #0f0; color: #000; }
        #btn-rec { background: #333; color: #ccc; }
        
        body.recording #btn-rec { background: #f00; color: #fff; animation: pulse 1s infinite; }
        @keyframes pulse { 50% { opacity: 0.5; } }

    </style>
</head>
<body>

    <div id="viz-area">
        <div class="warning-text" id="fb-warn">⚠️ USE HEADPHONES TO AVOID FEEDBACK</div>
        <div id="mode-label">REALITY</div>
        <div id="grain-indicator"></div>
    </div>

    <div class="controls">
        <!-- MORPH SLIDER -->
        <div class="morph-container">
            <div class="morph-labels">
                <span>MIC (DRY)</span>
                <span>MIX</span>
                <span>AMBIENT (WET)</span>
            </div>
            <input type="range" id="morph" min="0" max="100" value="100" step="1">
        </div>

        <!-- SETTINGS -->
        <div style="display: flex; gap: 10px;">
            <div style="flex:1">
                <label style="font-size: 10px; color:#666">BOOST</label>
                <input type="range" id="boost" min="1" max="20" value="3">
            </div>
            <div style="flex:1">
                <label style="font-size: 10px; color:#666">GRAIN SIZE</label>
                <input type="range" id="grain" min="0.1" max="0.5" step="0.05" value="0.2">
            </div>
        </div>

        <div class="btn-grid">
            <button id="btn-start">POWER ON</button>
            <button id="btn-rec">REC</button>
        </div>
    </div>

    <script>
        // --- VARS ---
        let ctx, stream, source, recorder;
        let masterGain, dryGain, wetGain; // Новые узлы микшера
        let destStream, mediaRecorder;
        
        let isRunning = false;
        let isRecording = false;
        let chunks = [];
        
        const BUFFER_SECS = 4;
        let recBuffer;
        let writePtr = 0;
        let bufLen = 0;

        // --- UI ---
        const morphSlider = document.getElementById('morph');
        const modeLabel = document.getElementById('mode-label');
        const fbWarn = document.getElementById('fb-warn');
        const grainInd = document.getElementById('grain-indicator');
        const btnStart = document.getElementById('btn-start');
        const btnRec = document.getElementById('btn-rec');

        // Логика слайдера MORPH
        morphSlider.oninput = updateMix;

        function updateMix() {
            if(!dryGain || !wetGain) return;
            
            // 0..1 value
            const val = parseInt(morphSlider.value) / 100;
            
            // Crossfade Logic
            // Dry (Mic) goes 1 -> 0
            dryGain.gain.value = 1.0 - val;
            
            // Wet (Synth) goes 0 -> 1
            wetGain.gain.value = val;

            // UI feedback
            if(val < 0.1) {
                modeLabel.innerText = "REALITY";
                modeLabel.style.color = "#fff";
                fbWarn.style.display = "block"; // Показываем предупреждение
            } else if (val > 0.9) {
                modeLabel.innerText = "DREAM";
                modeLabel.style.color = "#0f0";
                fbWarn.style.display = "none";
            } else {
                modeLabel.innerText = "MORPHING...";
                modeLabel.style.color = "#888";
            }
        }

        // --- INIT ---
        btnStart.onclick = async () => {
            if(isRunning) return;
            await initAudio();
        };

        async function initAudio() {
            try {
                const AC = window.AudioContext || window.webkitAudioContext;
                ctx = new AC({ latencyHint: 'interactive' });
                if(ctx.state === 'suspended') await ctx.resume();

                // 1. MIXER ARCHITECTURE
                masterGain = ctx.createGain(); // Финальная громкость
                masterGain.connect(ctx.destination);

                dryGain = ctx.createGain(); // Канал чистого микрофона
                wetGain = ctx.createGain(); // Канал гранулятора

                dryGain.connect(masterGain);
                wetGain.connect(masterGain);

                // Setup Recorder Destination
                destStream = ctx.createMediaStreamDestination();
                masterGain.connect(destStream); // Пишем то, что слышим (Mix)
                setupRecorder();

                // 2. INPUT
                stream = await navigator.mediaDevices.getUserMedia({
                    audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
                });
                source = ctx.createMediaStreamSource(stream);

                // 3. ROUTING
                // Ветка А: Мониторинг (Микрофон -> DryGain -> Выход)
                source.connect(dryGain);

                // Ветка Б: Запись в буфер для синтеза
                bufLen = ctx.sampleRate * BUFFER_SECS;
                recBuffer = new Float32Array(bufLen);
                
                // Chrome Hack (ScriptProcessor needs output)
                recorder = ctx.createScriptProcessor(4096, 1, 1);
                const mute = ctx.createGain(); mute.gain.value = 0;
                
                source.connect(recorder);
                recorder.connect(mute);
                mute.connect(ctx.destination);

                recorder.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    const boost = parseInt(document.getElementById('boost').value);
                    for(let i=0; i<input.length; i++) {
                        let v = input[i] * boost;
                        // Soft Clip
                        if(v>1) v=1; if(v<-1) v=-1;
                        
                        recBuffer[writePtr] = v;
                        writePtr = (writePtr + 1) % bufLen;
                    }
                };

                // Применяем начальное положение слайдера
                updateMix();

                // 4. START ENGINE
                isRunning = true;
                btnStart.innerText = "SYSTEM ACTIVE";
                btnStart.disabled = true;
                btnStart.style.opacity = 0.5;
                
                playBeep(); // Test sound
                scheduleGrain(); // Start Granulator

            } catch (e) {
                alert("Error: " + e.message);
            }
        }

        // --- GRANULAR ENGINE ---
        function scheduleGrain() {
            if(!isRunning) return;
            
            // Если WetGain почти ноль, мы не тратим ресурсы на создание звука?
            // Нет, лучше пусть работает, чтобы переход был бесшовным.
            playGrain();
            
            // Visual Blink (только если мы в режиме Dream или Mix)
            if(parseInt(morphSlider.value) > 10) {
                grainInd.style.opacity = 1;
                setTimeout(() => grainInd.style.opacity = 0, 50);
            }

            setTimeout(scheduleGrain, 50 + Math.random() * 50);
        }

        function playGrain() {
            const size = parseFloat(document.getElementById('grain').value);
            const len = Math.floor(size * ctx.sampleRate);
            const offset = Math.floor((0.1 + Math.random()) * ctx.sampleRate);
            
            let rPos = writePtr - offset;
            if(rPos < 0) rPos += bufLen;

            const buf = ctx.createBuffer(1, len, ctx.sampleRate);
            const dat = buf.getChannelData(0);
            for(let i=0; i<len; i++) {
                dat[i] = recBuffer[(rPos + i) % bufLen];
            }

            const src = ctx.createBufferSource();
            src.buffer = buf;
            src.playbackRate.value = 0.5 + Math.random()*0.5;

            const env = ctx.createGain();
            const t = ctx.currentTime;
            env.gain.setValueAtTime(0, t);
            env.gain.linearRampToValueAtTime(1, t + size/2);
            env.gain.linearRampToValueAtTime(0, t + size);

            const pan = ctx.createStereoPanner();
            pan.pan.value = Math.random()*2 - 1;

            // ВАЖНО: Подключаем к WET шине
            src.connect(env);
            env.connect(pan);
            pan.connect(wetGain); 

            src.start();
        }

        // --- RECORDER ---
        function setupRecorder() {
            try {
                mediaRecorder = new MediaRecorder(destStream.stream);
                mediaRecorder.ondataavailable = e => chunks.push(e.data);
                mediaRecorder.onstop = () => {
                    const blob = new Blob(chunks, {type:'audio/webm'});
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'flux_morph.webm';
                    a.click();
                    chunks = [];
                };
                
                btnRec.onclick = () => {
                    if(isRecording) {
                        mediaRecorder.stop();
                        isRecording = false;
                        document.body.classList.remove('recording');
                        btnRec.innerText = "REC";
                    } else {
                        mediaRecorder.start();
                        isRecording = true;
                        document.body.classList.add('recording');
                        btnRec.innerText = "STOP";
                    }
                };
            } catch(e) { console.log(e); }
        }

        function playBeep() {
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            o.connect(g); g.connect(masterGain);
            o.start(); g.gain.value = 0.1; o.stop(ctx.currentTime+0.1);
        }

    </script>
</body>
</html>
