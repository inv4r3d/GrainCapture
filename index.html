<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FLUX: BOOSTED</title>
    <style>
        body {
            background-color: #000;
            color: #0f0;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        /* Верхняя панель логов */
        #log {
            height: 30%;
            overflow-y: auto;
            padding: 10px;
            font-size: 11px;
            border-bottom: 1px solid #333;
            white-space: pre-wrap;
            background: #050505;
        }

        /* Визуализация */
        #viz-area {
            flex-grow: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 1px solid #333;
        }

        /* Мигающий индикатор зерна */
        #grain-indicator {
            width: 50px;
            height: 50px;
            background: #fff;
            opacity: 0;
            border-radius: 50%;
            transition: opacity 0.05s;
        }

        .status-overlay {
            position: absolute;
            bottom: 5px;
            left: 5px;
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 1px 2px #000;
        }

        /* Управление */
        .controls {
            padding: 20px;
            background: #111;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .slider-row label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #aaa;
        }

        input[type=range] {
            width: 100%;
            height: 30px; /* Большой палец */
        }

        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 20px;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
        }
    </style>
</head>
<body>

    <div id="log">SYSTEM READY.<br>TAP START BELOW.</div>

    <div id="viz-area">
        <div id="grain-indicator"></div>
        <div class="status-overlay" id="status-text">MIC: OFF</div>
    </div>

    <div class="controls">
        <div class="slider-row">
            <label><span>INPUT BOOST (GROMKOST)</span><span id="val-boost">x5</span></label>
            <input type="range" id="boost" min="1" max="20" step="1" value="5">
        </div>
        
        <div class="slider-row">
            <label>GRAIN SIZE</label>
            <input type="range" id="grain" min="0.1" max="0.5" step="0.05" value="0.2">
        </div>

        <button id="btn">START SYSTEM</button>
    </div>

    <script>
        // --- LOGGER ---
        const logEl = document.getElementById('log');
        function log(msg) {
            logEl.innerHTML = `> ${msg}\n` + logEl.innerHTML;
        }
        window.onerror = (e) => {
            // Игнорируем SCRIPT ERROR, он нам не мешает
            if(e.toString().includes('Script error')) return;
            log("ERR: " + e);
        };

        // --- GLOBALS ---
        let ctx, stream, source, recorder;
        let isRunning = false;
        
        const BUFFER_SECS = 4;
        let recBuffer;
        let writePtr = 0;
        let bufLen = 0;
        let grainTimer;

        // UI Elements
        const boostSlider = document.getElementById('boost');
        const boostVal = document.getElementById('val-boost');
        const statusText = document.getElementById('status-text');
        const grainInd = document.getElementById('grain-indicator');

        boostSlider.oninput = (e) => boostVal.innerText = "x" + e.target.value;

        // --- MAIN ---
        document.getElementById('btn').onclick = async function() {
            if(isRunning) { location.reload(); return; }
            await start();
        };

        async function start() {
            try {
                log("1. Init AudioContext...");
                const AC = window.AudioContext || window.webkitAudioContext;
                ctx = new AC({ latencyHint: 'playback' }); // 'playback' лучше для стабильности
                if(ctx.state === 'suspended') await ctx.resume();

                // TEST BEEP (ГРОМКИЙ)
                log("2. BEEP TEST...");
                playBeep();

                log("3. Mic Access...");
                stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false, // Выключаем шумодав для музыки
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                log("4. Setting up DSP...");
                bufLen = ctx.sampleRate * BUFFER_SECS;
                recBuffer = new Float32Array(bufLen);

                source = ctx.createMediaStreamSource(stream);
                
                // ScriptProcessor для записи
                recorder = ctx.createScriptProcessor(4096, 1, 1);
                
                // Mute hack for Chrome
                const mute = ctx.createGain();
                mute.gain.value = 0.0001;

                source.connect(recorder);
                recorder.connect(mute);
                mute.connect(ctx.destination);

                recorder.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    // INPUT BOOST (Предусилитель)
                    const boost = parseInt(boostSlider.value);
                    
                    let maxVal = 0;
                    for(let i=0; i<input.length; i++) {
                        // Умножаем сигнал на Boost
                        let val = input[i] * boost;
                        // Лимитер (Soft clip), чтобы не хрипело
                        if(val > 1) val = 1;
                        if(val < -1) val = -1;
                        
                        recBuffer[writePtr] = val;
                        
                        if(Math.abs(val) > maxVal) maxVal = Math.abs(val);
                        
                        writePtr++;
                        if(writePtr >= bufLen) writePtr = 0;
                    }

                    // Обновляем статус громкости
                    const db = 20 * Math.log10(maxVal);
                    statusText.innerText = `LEVEL: ${db.toFixed(1)} dB (Boost x${boost})`;
                };

                log("5. Starting Engine...");
                isRunning = true;
                scheduleGrain();
                
                document.getElementById('btn').innerText = "STOP / RESET";
                log("SUCCESS! Make some noise!");

            } catch(e) {
                log("FAIL: " + e.message);
                alert("Error: " + e.message);
            }
        }

        function playBeep() {
            const osc = ctx.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.value = 440;
            const g = ctx.createGain();
            g.gain.value = 0.5;
            osc.connect(g);
            g.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.3);
        }

        function scheduleGrain() {
            if(!isRunning) return;
            
            // Запускаем зерно
            playGrain();
            
            // Визуальный миг
            grainInd.style.opacity = 1;
            setTimeout(() => grainInd.style.opacity = 0, 50);

            // Следующее зерно через 50-100мс
            setTimeout(scheduleGrain, Math.random() * 50 + 50);
        }

        function playGrain() {
            // Берем настройки
            const size = parseFloat(document.getElementById('grain').value);
            const grainLen = Math.floor(size * ctx.sampleRate);
            
            // Читаем из прошлого (0.2 сек назад)
            // Добавляем случайность, чтобы не было "роботизированного" звука
            const offset = Math.floor((0.2 + Math.random() * 0.5) * ctx.sampleRate);
            
            let readPos = writePtr - offset;
            if(readPos < 0) readPos += bufLen;

            const buf = ctx.createBuffer(1, grainLen, ctx.sampleRate);
            const data = buf.getChannelData(0);

            for(let i=0; i<grainLen; i++) {
                let idx = (readPos + i) % bufLen;
                data[i] = recBuffer[idx];
            }

            const src = ctx.createBufferSource();
            src.buffer = buf;
            // Питч вниз для жирности
            src.playbackRate.value = 0.5 + Math.random() * 0.5;

            const env = ctx.createGain();
            // Огибающая (Fade In/Out)
            const t = ctx.currentTime;
            env.gain.setValueAtTime(0, t);
            env.gain.linearRampToValueAtTime(1.0, t + size/2);
            env.gain.linearRampToValueAtTime(0, t + size);

            src.connect(env);
            env.connect(ctx.destination);
            
            src.start();
        }

    </script>
</body>
</html>
