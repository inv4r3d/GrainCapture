<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>FLUX MONO FIXED</title>
    <style>
        :root {
            --bg: #000000;
            --fg: #ffffff;
            --dim: #444444;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: "Courier New", Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            height: 100dvh; /* Используем dynamic viewport height */
            margin: 0;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        header {
            width: 100%;
            padding: 15px;
            text-align: center;
            border-bottom: 1px solid var(--dim);
            letter-spacing: 2px;
            font-weight: bold;
            font-size: 14px;
            z-index: 10;
        }

        /* Область визуализации */
        #canvas-container {
            position: relative;
            flex-grow: 1;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #050505;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Консоль отладки на экране */
        #debug-console {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            font-size: 10px;
            color: var(--dim);
            text-align: center;
            pointer-events: none;
            white-space: pre-wrap; 
            font-family: monospace;
        }

        .controls {
            width: 100%;
            padding: 20px;
            background: var(--bg);
            border-top: 1px solid var(--dim);
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 10;
            box-sizing: border-box;
            /* Исправление для iPhone X+ safe area */
            padding-bottom: env(safe-area-inset-bottom, 20px); 
        }

        /* Слайдеры */
        .slider-group { display: flex; flex-direction: column; gap: 8px; }
        .slider-label { display: flex; justify-content: space-between; font-size: 11px; text-transform: uppercase; color: #888; }
        
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            margin: 0;
        }
        input[type=range]:focus { outline: none; }
        
        /* Дорожка слайдера */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: var(--dim);
        }
        input[type=range]::-moz-range-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: var(--dim);
        }
        
        /* Ползунок */
        input[type=range]::-webkit-slider-thumb {
            height: 24px;
            width: 24px;
            border: 2px solid var(--fg);
            background: #000;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -11px; /* Center */
        }
        input[type=range]::-moz-range-thumb {
            height: 24px;
            width: 24px;
            border: 2px solid var(--fg);
            background: #000;
            cursor: pointer;
        }

        /* Главная кнопка */
        #toggleBtn {
            background: transparent;
            color: var(--fg);
            border: 2px solid var(--fg);
            padding: 18px;
            font-family: inherit;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            transition: 0.1s;
        }
        
        #toggleBtn:active { background: var(--dim); }
        
        body.active #toggleBtn {
            background: var(--fg);
            color: var(--bg);
        }

        .rec-dot {
            width: 8px; height: 8px; background: currentColor; border-radius: 50%;
            display: none;
        }
        body.active .rec-dot { display: block; animation: blink 1.5s infinite; }
        @keyframes blink { 0% {opacity:1;} 50% {opacity:0.3;} 100% {opacity:1;} }

    </style>
</head>
<body>

    <header>FLUX // GRANULAR</header>

    <div id="canvas-container">
        <canvas id="vizCanvas"></canvas>
        <div id="debug-console">STATUS: WAITING FOR INPUT</div>
    </div>

    <div class="controls">
        <div class="slider-group">
            <div class="slider-label"><span>Grain Size</span><span id="val-size">0.15s</span></div>
            <input type="range" id="grainSize" min="0.05" max="0.5" step="0.01" value="0.15">
        </div>

        <div class="slider-group">
            <div class="slider-label"><span>Density</span><span id="val-dens">Mid</span></div>
            <input type="range" id="density" min="20" max="300" step="10" value="80" style="direction: rtl">
        </div>

        <div class="slider-group">
            <div class="slider-label"><span>Reverb</span><span id="val-mix">60%</span></div>
            <input type="range" id="verbMix" min="0" max="1" step="0.01" value="0.6">
        </div>

        <button id="toggleBtn">
            <div class="rec-dot"></div>
            <span id="btnText">START SYSTEM</span>
        </button>
    </div>

    <script>
        // --- Логирование на экран (чтобы понять ошибку на телефоне) ---
        const debugConsole = document.getElementById('debug-console');
        function log(msg) {
            console.log(msg);
            debugConsole.innerText = msg;
        }
        window.onerror = function(msg, url, line) {
            log("ERR: " + msg);
            return false;
        };

        // --- UI ---
        const btn = document.getElementById('toggleBtn');
        const btnText = document.getElementById('btnText');
        
        // Обработка слайдеров
        document.getElementById('grainSize').oninput = (e) => document.getElementById('val-size').innerText = e.target.value + 's';
        document.getElementById('density').oninput = (e) => document.getElementById('val-dens').innerText = e.target.value + 'ms';
        document.getElementById('verbMix').oninput = (e) => document.getElementById('val-mix').innerText = Math.round(e.target.value * 100) + '%';

        // --- Аудио переменные ---
        let audioCtx;
        let isRunning = false;
        let stream;
        
        // Граф
        let sourceNode;   // Микрофон
        let analyser;     // Визуализатор
        let recorderNode; // Запись в буфер
        let muteNode;     // Заглушка, чтобы не было фидбека
        
        // Эффекты
        let compressor;
        let reverbNode;
        let dryGain, wetGain;

        // Буфер
        const BUFFER_SECS = 4;
        let bufferL;
        let writePtr = 0;
        let bufLen = 0;

        // Таймер генерации зерен
        let grainTimeout;

        // --- Visualizer ---
        const canvas = document.getElementById('vizCanvas');
        const ctx = canvas.getContext('2d');
        let animationId;

        function resize() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- START / STOP LOGIC ---
        
        btn.addEventListener('click', async () => {
            if (!isRunning) {
                await initAudio();
            } else {
                stopAudio();
            }
        });

        async function initAudio() {
            try {
                log("Init: Creating AudioContext...");
                
                // 1. Создаем контекст (обязательно внутри клика для iOS)
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) throw new Error("WebAudio not supported");
                
                if (!audioCtx) audioCtx = new AudioContext({ latencyHint: 'interactive' });
                
                // 2. Обязательный 'resume' для iOS
                if (audioCtx.state === 'suspended') {
                    await audioCtx.resume();
                }

                log("Init: Requesting Mic...");
                // 3. Запрос микрофона
                stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false, // Важно для музыки
                        autoGainControl: false,
                        noiseSuppression: false
                    }
                });

                log("Init: Setup Graph...");
                
                // 4. Настройка буферов
                bufLen = audioCtx.sampleRate * BUFFER_SECS;
                bufferL = new Float32Array(bufLen);
                writePtr = 0;

                // 5. Создание узлов
                sourceNode = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 2048; // Лучшее разрешение для волны
                analyser.smoothingTimeConstant = 0.2;

                // ScriptProcessor: 
                // Создаем узел для захвата данных (deprecated, но работает везде)
                // Размер буфера 4096 дает баланс между стабильностью и частотой обновления
                recorderNode = audioCtx.createScriptProcessor(4096, 1, 1);
                
                // Mute Node: 
                // Важнейший момент! Мы подключаем Recorder к выходу, но ставим громкость 0.
                // Это заставляет браузер обрабатывать звук, но мы не слышим прямой сигнал (нет свиста).
                muteNode = audioCtx.createGain();
                muteNode.gain.value = 0;

                // 6. Подключение (Routing)
                
                // Ветка 1: Визуализация
                sourceNode.connect(analyser);
                
                // Ветка 2: Запись в буфер
                sourceNode.connect(recorderNode);
                recorderNode.connect(muteNode);
                muteNode.connect(audioCtx.destination); // Замыкаем цепь, чтобы процесс шел

                // Логика записи
                recorderNode.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    // Пишем в кольцевой буфер
                    for (let i = 0; i < input.length; i++) {
                        bufferL[writePtr] = input[i];
                        writePtr++;
                        if (writePtr >= bufLen) writePtr = 0;
                    }
                };

                // Ветка 3: Эффекты (Куда будут лететь зерна)
                await setupEffects();

                // 7. Запуск
                scheduleGrain(); // Запуск мотора гранулятора
                drawVisualizer(); // Запуск рисования

                isRunning = true;
                document.body.classList.add('active');
                btnText.innerText = "STOP SYSTEM";
                log("STATUS: RUNNING [REC]");

            } catch (e) {
                console.error(e);
                log("ERROR: " + e.message);
                alert("Ошибка доступа: " + e.message + "\n\n1. Проверьте HTTPS.\n2. Разрешите микрофон.\n3. Подключите наушники.");
            }
        }

        function stopAudio() {
            clearTimeout(grainTimeout);
            cancelAnimationFrame(animationId);
            
            if (sourceNode) sourceNode.disconnect();
            if (recorderNode) recorderNode.disconnect();
            if (muteNode) muteNode.disconnect();
            if (stream) stream.getTracks().forEach(t => t.stop());
            
            // Очищаем Canvas
            ctx.clearRect(0,0, canvas.width, canvas.height);
            
            isRunning = false;
            document.body.classList.remove('active');
            btnText.innerText = "START SYSTEM";
            log("STATUS: STOPPED");
        }

        // --- Эффекты ---
        async function setupEffects() {
            compressor = audioCtx.createDynamicsCompressor();
            compressor.threshold.value = -12;
            
            reverbNode = audioCtx.createConvolver();
            // Генерируем "белый шум" как импульс для ревербератора
            const tailSeconds = 3;
            const length = audioCtx.sampleRate * tailSeconds;
            const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);
            for (let ch = 0; ch < 2; ch++) {
                const data = impulse.getChannelData(ch);
                for (let i = 0; i < length; i++) {
                    const decay = Math.pow(1 - i / length, 4); // Резкий спад
                    data[i] = (Math.random() * 2 - 1) * decay;
                }
            }
            reverbNode.buffer = impulse;

            dryGain = audioCtx.createGain();
            wetGain = audioCtx.createGain();
            updateMix();

            // Выход эффектов -> Compressor -> Master
            dryGain.connect(compressor);
            wetGain.connect(reverbNode);
            reverbNode.connect(compressor);
            compressor.connect(audioCtx.destination);
        }

        function updateMix() {
            if (!dryGain) return;
            const val = parseFloat(document.getElementById('verbMix').value);
            dryGain.gain.value = 1.0 - (val * 0.5);
            wetGain.gain.value = val;
        }
        document.getElementById('verbMix').addEventListener('input', updateMix);

        // --- Granular Engine (Сердце) ---
        function scheduleGrain() {
            if (!isRunning) return;

            const density = parseInt(document.getElementById('density').value);
            // Случайный разброс времени старта следующего зерна
            const nextTime = density + (Math.random() * 20); 
            
            playGrain();
            
            grainTimeout = setTimeout(scheduleGrain, nextTime);
        }

        function playGrain() {
            // Если буфер еще пуст (начало работы), не играем
            if (writePtr < 1000 && bufLen === 0) return;

            const grainSize = parseFloat(document.getElementById('grainSize').value);
            const grainLen = Math.floor(grainSize * audioCtx.sampleRate);
            
            // Берем кусок из прошлого (от 0.2с до 2с назад)
            // Важно: отступаем от writePtr, чтобы не читать то, что сейчас пишется
            const offset = Math.floor((Math.random() * 1.8 + 0.2) * audioCtx.sampleRate);
            let readPos = writePtr - offset;
            if (readPos < 0) readPos += bufLen;

            // Создаем буфер для одного зерна
            const buffer = audioCtx.createBuffer(1, grainLen, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            // Копируем данные
            for (let i = 0; i < grainLen; i++) {
                let idx = readPos + i;
                if (idx >= bufLen) idx -= bufLen; // Кольцо
                data[i] = bufferL[idx];
            }

            // Создаем источник звука
            const src = audioCtx.createBufferSource();
            src.buffer = buffer;

            // Питч (замедление/ускорение)
            // 0.5 = октава вниз, 1.0 = нормально
            const rate = 0.5 + Math.random() * 0.7; 
            src.playbackRate.value = rate;

            // Огибающая (Envelope) - чтобы убрать щелчки
            const env = audioCtx.createGain();
            const now = audioCtx.currentTime;
            env.gain.setValueAtTime(0, now);
            env.gain.linearRampToValueAtTime(0.8, now + (grainSize * 0.2)); // Attack
            env.gain.linearRampToValueAtTime(0, now + grainSize);       // Release

            // Панорама
            const panner = audioCtx.createStereoPanner();
            panner.pan.value = Math.random() * 2 - 1;

            // Соединяем
            src.connect(env);
            env.connect(panner);
            panner.connect(dryGain);
            panner.connect(wetGain);

            src.start();
        }

        // --- Визуализация (Осциллограмма) ---
        function drawVisualizer() {
            if (!isRunning) return;
            animationId = requestAnimationFrame(drawVisualizer);

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.lineWidth = 2;
            ctx.strokeStyle = '#ffffff';
            ctx.beginPath();

            const sliceWidth = canvas.width * 1.0 / bufferLength;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0; // 1.0 - центр (тишина)
                const y = v * (canvas.height / 2);

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);

                x += sliceWidth;
            }

            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
        }

    </script>
</body>
</html>
