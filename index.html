<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FLUX: FINAL</title>
    <style>
        body {
            background-color: #000;
            color: #eee;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh; /* Mobile fix */
            margin: 0;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        /* --- VISUALS --- */
        #viz-area {
            flex-grow: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-bottom: 1px solid #333;
        }

        #mode-label {
            font-size: 20px;
            font-weight: bold;
            letter-spacing: 4px;
            color: #555;
            transition: color 0.3s;
            margin-bottom: 10px;
        }

        /* Анимация круга при генерации зерна */
        #grain-indicator {
            width: 12px; height: 12px;
            background: #fff;
            border-radius: 50%;
            opacity: 0;
            box-shadow: 0 0 20px #fff;
            transition: opacity 0.1s;
        }

        /* Таймер записи */
        #rec-timer {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 14px;
            color: #f00;
            display: none;
            font-weight: bold;
        }

        /* --- CONTROLS --- */
        .controls {
            padding: 20px;
            background: #111;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding-bottom: env(safe-area-inset-bottom, 25px);
        }

        .morph-container { display: flex; flex-direction: column; gap: 5px; }
        
        .morph-labels {
            display: flex; justify-content: space-between;
            font-size: 11px; color: #666; font-weight: bold;
        }

        input[type=range] { width: 100%; height: 30px; -webkit-appearance: none; background: transparent; }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 28px; width: 28px;
            background: #fff; border-radius: 50%;
            margin-top: -12px;
            box-shadow: 0 2px 5px #000;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: #333; border-radius: 2px;
        }

        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        
        button {
            border: none; padding: 18px;
            font-size: 14px; font-weight: bold;
            text-transform: uppercase; cursor: pointer;
            font-family: monospace; border-radius: 4px;
            transition: all 0.2s;
        }

        /* POWER BTN STYLES */
        #btn-power { background: #eee; color: #000; }
        #btn-power.active { background: #333; color: #eee; border: 1px solid #555; }

        /* REC BTN STYLES */
        #btn-rec { background: #222; color: #666; border: 1px solid #333; }
        
        /* Active Recording */
        body.recording #btn-rec { 
            background: #900; color: #fff; border-color: #f00;
            animation: pulse-rec 1.5s infinite; 
        }
        @keyframes pulse-rec { 50% { opacity: 0.6; } }

    </style>
</head>
<body>

    <div id="viz-area">
        <div id="mode-label">STANDBY</div>
        <div id="grain-indicator"></div>
        <div id="rec-timer">00:00</div>
    </div>

    <div class="controls">
        <!-- MORPH SLIDER -->
        <div class="morph-container">
            <div class="morph-labels">
                <span>MIC (DRY)</span>
                <span>MIX</span>
                <span>SYNTH (WET)</span>
            </div>
            <input type="range" id="morph" min="0" max="100" value="100" step="1">
        </div>

        <!-- SETTINGS -->
        <div style="display: flex; gap: 15px;">
            <div style="flex:1">
                <label style="font-size: 10px; color:#666">SENSITIVITY</label>
                <input type="range" id="boost" min="1" max="15" value="4">
            </div>
            <div style="flex:1">
                <label style="font-size: 10px; color:#666">GRAIN SIZE</label>
                <input type="range" id="grain" min="0.1" max="0.6" step="0.05" value="0.25">
            </div>
        </div>

        <div class="btn-grid">
            <button id="btn-power">POWER ON</button>
            <button id="btn-rec">REC</button>
        </div>
    </div>

    <script>
        // --- GLOBALS ---
        let audioCtx;
        let stream, source, recorderNode;
        let masterGain, dryGain, wetGain;
        let destStream, mediaRecorder;
        
        let isRunning = false;
        let isRecording = false;
        let recChunks = [];
        let recStartTime = 0;
        let recTimerInterval;
        
        // Circular Buffer
        const BUFFER_SECS = 4;
        let recBuffer;
        let writePtr = 0;
        let bufLen = 0;
        let grainTimeout;

        // UI Refs
        const btnPower = document.getElementById('btn-power');
        const btnRec = document.getElementById('btn-rec');
        const morphSlider = document.getElementById('morph');
        const modeLabel = document.getElementById('mode-label');
        const grainInd = document.getElementById('grain-indicator');
        const recTimerDisp = document.getElementById('rec-timer');

        // --- POWER LOGIC ---
        btnPower.onclick = async () => {
            if (!isRunning) {
                await startSystem();
            } else {
                stopSystem();
            }
        };

        async function startSystem() {
            try {
                // 1. Init Context
                const AC = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AC({ latencyHint: 'interactive' });
                
                // iOS Unlock
                if (audioCtx.state === 'suspended') await audioCtx.resume();

                // 2. Routing Setup
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 1.0;
                masterGain.connect(audioCtx.destination); // Headphones Output

                dryGain = audioCtx.createGain();
                wetGain = audioCtx.createGain();
                dryGain.connect(masterGain);
                wetGain.connect(masterGain);

                // Recorder Line Setup
                destStream = audioCtx.createMediaStreamDestination();
                masterGain.connect(destStream); 
                setupMediaRecorder();

                // 3. Microphone (Critical for Headphones)
                stream = await navigator.mediaDevices.getUserMedia({
                    audio: { 
                        echoCancellation: false, // Essential for music, but tricky for feedback
                        noiseSuppression: false, 
                        autoGainControl: false 
                    }
                });

                // 4. Processing Chain
                source = audioCtx.createMediaStreamSource(stream);
                
                // Route A: Monitor (Dry)
                source.connect(dryGain);

                // Route B: Capture (Buffer)
                bufLen = audioCtx.sampleRate * BUFFER_SECS;
                recBuffer = new Float32Array(bufLen);
                
                // ScriptProcessor for raw data access
                recorderNode = audioCtx.createScriptProcessor(4096, 1, 1);
                recorderNode.onaudioprocess = processAudioInput;
                
                // Keep-alive hack
                const muteNode = audioCtx.createGain();
                muteNode.gain.value = 0;
                source.connect(recorderNode);
                recorderNode.connect(muteNode);
                muteNode.connect(audioCtx.destination);

                // UI Update
                isRunning = true;
                btnPower.innerText = "POWER OFF";
                btnPower.classList.add('active');
                updateMix(); // Apply slider value
                
                // Start Engines
                scheduleGrain();
                playBeep(); // Confirmation sound

            } catch (err) {
                alert("Ошибка запуска: " + err.message + "\nПопробуйте переподключить наушники.");
                console.error(err);
                stopSystem();
            }
        }

        function stopSystem() {
            // Stop Loops
            clearTimeout(grainTimeout);
            clearInterval(recTimerInterval);

            // Stop Recording if active
            if(isRecording) stopRecording();

            // Disconnect Audio
            if(source) source.disconnect();
            if(recorderNode) recorderNode.disconnect();
            if(stream) stream.getTracks().forEach(t => t.stop());
            if(audioCtx) audioCtx.close();

            // Reset UI
            isRunning = false;
            btnPower.innerText = "POWER ON";
            btnPower.classList.remove('active');
            modeLabel.innerText = "STANDBY";
            modeLabel.style.color = "#555";
            recTimerDisp.style.display = 'none';
        }

        // --- AUDIO PROCESSING ---
        function processAudioInput(e) {
            const input = e.inputBuffer.getChannelData(0);
            const boost = parseInt(document.getElementById('boost').value);
            
            for(let i=0; i<input.length; i++) {
                let v = input[i] * boost;
                // Soft Limiter
                if(v > 1) v = 1; 
                if(v < -1) v = -1;
                
                recBuffer[writePtr] = v;
                writePtr = (writePtr + 1) % bufLen;
            }
        }

        // --- GRANULAR ENGINE ---
        function scheduleGrain() {
            if(!isRunning) return;
            playGrain();
            
            // Visual Blink (Only if Wet Mix is audible)
            if(parseInt(morphSlider.value) > 10) {
                grainInd.style.opacity = 1;
                setTimeout(() => grainInd.style.opacity = 0, 50);
            }

            // Next grain
            grainTimeout = setTimeout(scheduleGrain, 60 + Math.random() * 60);
        }

        function playGrain() {
            const size = parseFloat(document.getElementById('grain').value);
            const len = Math.floor(size * audioCtx.sampleRate);
            
            // Random Past
            const offset = Math.floor((0.15 + Math.random() * 1.5) * audioCtx.sampleRate);
            let rPos = writePtr - offset;
            if(rPos < 0) rPos += bufLen;

            // Create Buffer
            const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
            const dat = buf.getChannelData(0);
            // Copy loop
            for(let i=0; i<len; i++) {
                dat[i] = recBuffer[(rPos + i) % bufLen];
            }

            // Source
            const src = audioCtx.createBufferSource();
            src.buffer = buf;
            src.playbackRate.value = 0.5 + Math.random()*0.5; // Pitch Down

            // Envelope
            const env = audioCtx.createGain();
            const t = audioCtx.currentTime;
            env.gain.setValueAtTime(0, t);
            env.gain.linearRampToValueAtTime(1, t + size * 0.4);
            env.gain.linearRampToValueAtTime(0, t + size);

            // Panner
            const pan = audioCtx.createStereoPanner();
            pan.pan.value = Math.random()*2 - 1;

            // Route to Wet
            src.connect(env);
            env.connect(pan);
            pan.connect(wetGain);

            src.start();
        }

        // --- MIXER LOGIC ---
        morphSlider.oninput = updateMix;
        function updateMix() {
            if(!isRunning) return;
            const val = parseInt(morphSlider.value);
            const norm = val / 100;

            // Crossfade
            dryGain.gain.value = 1.0 - norm;
            wetGain.gain.value = norm;

            // Label
            if(val < 10) {
                modeLabel.innerText = "REALITY (MIC)";
                modeLabel.style.color = "#fff";
            } else if (val > 90) {
                modeLabel.innerText = "DREAM (SYNTH)";
                modeLabel.style.color = "#0f0";
            } else {
                modeLabel.innerText = "MORPHING...";
                modeLabel.style.color = "#888";
            }
        }

        // --- RECORDING LOGIC ---
        function setupMediaRecorder() {
            // Detect support
            let mimeType = 'audio/webm';
            if(!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'audio/mp4'; // Safari fallback

            try {
                mediaRecorder = new MediaRecorder(destStream.stream, { mimeType: mimeType });
            } catch(e) {
                mediaRecorder = new MediaRecorder(destStream.stream); // Generic fallback
            }

            mediaRecorder.ondataavailable = e => {
                if(e.data.size > 0) recChunks.push(e.data);
            };

            mediaRecorder.onstop = saveRecording;
        }

        btnRec.onclick = () => {
            if(!isRunning) return;
            if(!isRecording) startRecording();
            else stopRecording();
        };

        function startRecording() {
            recChunks = [];
            mediaRecorder.start();
            isRecording = true;
            document.body.classList.add('recording');
            recTimerDisp.style.display = 'block';
            recStartTime = Date.now();
            
            // Timer Update
            recTimerInterval = setInterval(() => {
                const diff = Math.floor((Date.now() - recStartTime) / 1000);
                const m = Math.floor(diff / 60).toString().padStart(2,'0');
                const s = (diff % 60).toString().padStart(2,'0');
                recTimerDisp.innerText = `${m}:${s}`;
            }, 1000);
        }

        function stopRecording() {
            mediaRecorder.stop(); // Triggers onstop -> saveRecording
            isRecording = false;
            document.body.classList.remove('recording');
            clearInterval(recTimerInterval);
            recTimerDisp.innerText = "SAVING...";
            
            // Blink effect on save
            setTimeout(() => {
                recTimerDisp.style.display = 'none';
                recTimerDisp.innerText = "00:00";
            }, 3000);
        }

        function saveRecording() {
            const blob = new Blob(recChunks, { type: 'audio/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            
            // Timestamp name
            const now = new Date();
            const timeStr = now.getHours() + "-" + now.getMinutes() + "-" + now.getSeconds();
            a.download = `flux_recording_${timeStr}.webm`;
            
            document.body.appendChild(a);
            a.click();
            
            // Cleanup
            setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 100);
        }

        function playBeep() {
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.connect(g); g.connect(masterGain);
            o.start(); g.gain.value = 0.1; o.stop(audioCtx.currentTime+0.15);
        }

    </script>
</body>
</html>
