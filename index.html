<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FLUX DEBUG</title>
    <style>
        body {
            background-color: #000;
            color: #fff;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            text-transform: uppercase;
        }

        /* --- LOG CONSOLE --- */
        #log {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 10px;
            border-bottom: 1px solid #333;
            color: #0f0; /* Green terminal style */
            white-space: pre-wrap;
        }

        /* --- VISUALIZER --- */
        #viz-container {
            height: 150px;
            width: 100%;
            border-bottom: 1px solid #333;
            position: relative;
        }
        canvas { width: 100%; height: 100%; display: block; }
        
        #vol-meter {
            position: absolute;
            bottom: 5px;
            left: 5px;
            font-size: 12px;
            background: #000;
            padding: 2px;
        }

        /* --- CONTROLS --- */
        .controls {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: #111;
        }

        button {
            background: #fff;
            color: #000;
            border: none;
            padding: 20px;
            font-family: inherit;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
        }
        button:active { background: #888; }

        .slider-row { display: flex; justify-content: space-between; align-items: center; }
        input[type=range] { flex-grow: 1; margin-left: 10px; }

    </style>
</head>
<body>

    <div id="log">SYSTEM READY...<br>WAITING FOR USER INTERACTION...</div>

    <div id="viz-container">
        <canvas id="c"></canvas>
        <div id="vol-meter">MIC LEVEL: 0.00</div>
    </div>

    <div class="controls">
        <div class="slider-row">
            <span>GRAIN</span>
            <input type="range" id="grain" min="0.05" max="0.5" step="0.01" value="0.2">
        </div>
        <div class="slider-row">
            <span>DENS</span>
            <input type="range" id="dens" min="20" max="300" step="10" value="80" style="direction: rtl">
        </div>
        <button id="btn">START / INITIALIZE</button>
    </div>

    <script>
        // --- LOGGER UTILITY ---
        const logEl = document.getElementById('log');
        function log(msg) {
            const time = new Date().toLocaleTimeString();
            logEl.innerHTML += `[${time}] ${msg}<br>`;
            logEl.scrollTop = logEl.scrollHeight;
            console.log(msg);
        }
        window.onerror = (msg) => log("JS ERROR: " + msg);

        // --- VARS ---
        let ctx, stream, source, analyser, recorder;
        let isRunning = false;
        
        // Buffers
        const BUFFER_SIZE = 5; // seconds
        let recBuffer;
        let writeIdx = 0;
        let bufLen = 0;
        let grainTimer;

        // UI
        const cvs = document.getElementById('c');
        const cx = cvs.getContext('2d');
        const volText = document.getElementById('vol-meter');

        function resize() {
            cvs.width = cvs.clientWidth;
            cvs.height = cvs.clientHeight;
        }
        window.onresize = resize;
        resize();

        // --- MAIN LOGIC ---
        document.getElementById('btn').onclick = async () => {
            if (isRunning) {
                location.reload(); // Hard reset is safer
                return;
            }
            await init();
        };

        async function init() {
            try {
                log("1. Creating AudioContext...");
                const AC = window.AudioContext || window.webkitAudioContext;
                ctx = new AC({ latencyHint: 'interactive' });
                
                if (ctx.state === 'suspended') {
                    log("Context suspended. Resuming...");
                    await ctx.resume();
                }

                // TEST TONE (Проверка динамиков)
                log("2. Playing Test Tone (BEEP)...");
                const osc = ctx.createOscillator();
                const g = ctx.createGain();
                osc.connect(g);
                g.connect(ctx.destination);
                osc.start();
                g.gain.value = 0.1;
                osc.stop(ctx.currentTime + 0.2); // 200ms beep

                log("3. Requesting Mic...");
                // Просим браузер не обрабатывать звук (даем сырой сигнал)
                stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });
                
                // Проверка: какие треки получили
                const tracks = stream.getAudioTracks();
                if (tracks.length > 0) {
                    log(`Mic Info: ${tracks[0].label} (Ready: ${tracks[0].readyState})`);
                } else {
                    throw new Error("No audio tracks found!");
                }

                // --- AUDIO GRAPH ---
                log("4. Building Graph...");
                
                bufLen = ctx.sampleRate * BUFFER_SIZE;
                recBuffer = new Float32Array(bufLen);

                source = ctx.createMediaStreamSource(stream);
                analyser = ctx.createAnalyser();
                analyser.fftSize = 2048;

                // ВАЖНО: Хак для Chrome. Создаем ScriptProcessor, который пишет в буфер.
                // Он ДОЛЖЕН быть подключен к destination, но громкость должна быть почти 0, но не 0.
                recorder = ctx.createScriptProcessor(4096, 1, 1);
                
                const keepAliveGain = ctx.createGain();
                keepAliveGain.gain.value = 0.0001; // ОЧЕНЬ ТИХО, но не ноль

                // Цепочка: Mic -> Analyser -> Recorder -> Gain(Tiny) -> Speakers
                source.connect(analyser);
                source.connect(recorder);
                recorder.connect(keepAliveGain);
                keepAliveGain.connect(ctx.destination);

                // Логика записи
                recorder.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    // Простая проверка громкости (RMS)
                    let sum = 0;
                    for (let i = 0; i < input.length; i++) {
                        recBuffer[writeIdx] = input[i];
                        sum += input[i] * input[i];
                        writeIdx++;
                        if (writeIdx >= bufLen) writeIdx = 0;
                    }
                    // Вывод уровня громкости на экран для отладки
                    const rms = Math.sqrt(sum / input.length);
                    const db = 20 * Math.log10(rms);
                    volText.innerText = `LEVEL: ${rms.toFixed(4)} (${db.toFixed(1)} dB)`;
                };

                // Запуск гранулятора
                log("5. Starting Granular Engine...");
                scheduleGrain();
                draw();

                isRunning = true;
                document.getElementById('btn').innerText = "STOP / RELOAD";
                log("SUCCESS. TALK NOW.");

            } catch (err) {
                log("CRITICAL ERROR: " + err.message);
                alert("Error: " + err.message);
            }
        }

        // --- GRANULAR ENGINE (Simplified for stability) ---
        let dryNode, wetNode, reverb;

        // Создаем ревербератор и шины один раз
        async function getReverb() {
            if (reverb) return reverb;
            const convo = ctx.createConvolver();
            
            // Генерируем импульс (2 секунды шума)
            const len = ctx.sampleRate * 2;
            const buf = ctx.createBuffer(2, len, ctx.sampleRate);
            for(let c=0;c<2;c++){
                const d = buf.getChannelData(c);
                for(let i=0;i<len;i++) d[i] = (Math.random()*2-1) * Math.pow(1-i/len, 2);
            }
            convo.buffer = buf;
            
            // Compressor Limiter
            const comp = ctx.createDynamicsCompressor();
            convo.connect(comp);
            comp.connect(ctx.destination);
            
            return comp; // Возвращаем точку входа (компрессор, на самом деле лучше микшер)
        }

        async function scheduleGrain() {
            if (!isRunning) return;
            
            const density = parseInt(document.getElementById('dens').value);
            const size = parseFloat(document.getElementById('grain').value);

            // Если буфер заполнен хотя бы немного
            if (writeIdx > 1000 || recBuffer[bufLen-1] !== 0) {
                playGrain(size);
            }

            setTimeout(scheduleGrain, density + Math.random()*20);
        }

        function playGrain(duration) {
            const grainLen = Math.floor(duration * ctx.sampleRate);
            
            // Случайный отступ назад (0.1 - 1.5 сек)
            const offset = Math.floor((Math.random() * 1.4 + 0.1) * ctx.sampleRate);
            let readPos = writeIdx - offset;
            if (readPos < 0) readPos += bufLen;

            // Копируем данные
            const buf = ctx.createBuffer(1, grainLen, ctx.sampleRate);
            const data = buf.getChannelData(0);
            for(let i=0; i<grainLen; i++) {
                let idx = (readPos + i) % bufLen;
                data[i] = recBuffer[idx];
            }

            const src = ctx.createBufferSource();
            src.buffer = buf;
            src.playbackRate.value = 0.5 + Math.random() * 0.5; // Pitch down

            const env = ctx.createGain();
            env.gain.setValueAtTime(0, ctx.currentTime);
            env.gain.linearRampToValueAtTime(0.5, ctx.currentTime + duration/2);
            env.gain.linearRampToValueAtTime(0, ctx.currentTime + duration);

            // Simple Reverb send logic (creating impulse every time is expensive, let's fake it with long release for now or use global reverb)
            // Для теста просто выводим в destination через Envelope
            src.connect(env);
            env.connect(ctx.destination);
            
            src.start();
        }

        // --- VISUALIZER ---
        function draw() {
            if(!isRunning) return;
            requestAnimationFrame(draw);
            
            const len = analyser.frequencyBinCount;
            const data = new Uint8Array(len);
            analyser.getByteTimeDomainData(data);

            cx.fillStyle = '#000';
            cx.fillRect(0,0, cvs.width, cvs.height);
            cx.strokeStyle = '#0f0';
            cx.lineWidth = 2;
            cx.beginPath();

            const slice = cvs.width / len;
            let x = 0;
            for(let i=0; i<len; i++) {
                const v = data[i] / 128.0;
                const y = v * cvs.height/2;
                i===0 ? cx.moveTo(x,y) : cx.lineTo(x,y);
                x+=slice;
            }
            cx.stroke();
        }

    </script>
</body>
</html>
